package today.sleek.client.modules.impl.exploit.disabler.watchdog

import net.minecraft.network.Packet
import net.minecraft.network.play.client.C00PacketKeepAlive
import net.minecraft.network.play.client.C03PacketPlayer
import net.minecraft.network.play.client.C0FPacketConfirmTransaction
import net.minecraft.network.play.server.S08PacketPlayerPosLook
import today.sleek.base.event.impl.PacketEvent
import today.sleek.base.event.impl.UpdateEvent
import today.sleek.client.gui.notification.Notification
import today.sleek.client.gui.notification.Notification.NotificationType
import today.sleek.client.gui.notification.NotificationManager
import today.sleek.client.modules.impl.exploit.disabler.DisablerMode
import today.sleek.client.utils.chat.ChatUtil
import today.sleek.client.utils.math.MathUtil
import today.sleek.client.utils.math.Stopwatch
import today.sleek.client.utils.network.PacketUtil
import today.sleek.client.utils.player.PlayerUtil


/**
 * @author Kansio
 */
class Test : DisablerMode("Watchdog Test") {

    private var toCancel: Long = 0

    private val delay1: Stopwatch = Stopwatch()
    private val delay2: Stopwatch = Stopwatch()

    private val packetQueue: ArrayDeque<Packet<*>> = ArrayDeque()

    override fun onEnable() {
        packetQueue.clear()
    }

    override fun onUpdate(event: UpdateEvent) {
        if (event.isPre && toCancel < 0) {

            if (delay2.timeElapsed(
                    (
                            if (mc.thePlayer.ticksExisted < 120)
                                1920
                            else
                                MathUtil.getRandomInRange(1, 250)).toLong()
                )
            ) {

                //send packets
                while (!packetQueue.isEmpty()) {
                    PacketUtil.sendPacketNoEvent(packetQueue.removeLast())
                    ChatUtil.log("sent packet")
                }

                delay2.resetTime()
            }

            if (mc.thePlayer.ticksExisted == 120) {
                NotificationManager.getNotificationManager()
                    .show(Notification(NotificationType.TIME, "Disabler", "Watchdog has been disabled!", 3))

                event.posX = event.posX + 1
                event.posZ = event.posZ + 1
            }
        }
    }

    override fun onPacket(event: PacketEvent) {
        val packet = event.getPacket<Packet<*>>()

        if (packet is S08PacketPlayerPosLook) {
            val playerPosLook = event.getPacket<S08PacketPlayerPosLook>()

            if (mc.thePlayer.ticksExisted < 5)
                return

            if (!PlayerUtil.isBlockUnder())
                return

            if (PlayerUtil.isOverVoid())
                return

            if (delay1.timeElapsed(2000)) {
                if (mc.thePlayer.getDistance(playerPosLook.getX(), playerPosLook.getY(), playerPosLook.getZ()) < 10) {
                    toCancel = 6
                    event.isCancelled = true
                }
                delay1.resetTime()
            }
        }

        if (packet is C03PacketPlayer) {
            if (toCancel > 0) {
                event.isCancelled = true
                toCancel--
                return
            }

            if (!packet.isMoving && packet.getRotating()) {
                event.isCancelled = true
            }
        }

        if (mc.thePlayer.ticksExisted < 120) {
            if (packet is C03PacketPlayer) {
                if (!packet.isMoving && !packet.getRotating()) {
                    event.isCancelled = true
                } else {
                    packetQueue.addFirst(packet)
                    event.isCancelled = true
                }
            }
            if (packet is C00PacketKeepAlive) {
                packetQueue.addFirst(packet)
                event.isCancelled = true
            }
            if (packet is C0FPacketConfirmTransaction) {
                packetQueue.addFirst(packet)
                event.isCancelled = true
            }
        }
    }
}
