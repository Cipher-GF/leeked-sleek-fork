package today.sleek.client.modules.impl.exploit

import today.sleek.base.modules.ModuleData
import today.sleek.base.modules.ModuleCategory
import today.sleek.base.value.value.NumberValue
import today.sleek.base.value.value.ModeValue
import com.google.common.eventbus.Subscribe
import today.sleek.base.event.impl.UpdateEvent
import net.minecraft.network.play.client.C03PacketPlayer
import net.minecraft.network.play.client.C03PacketPlayer.C06PacketPlayerPosLook
import net.minecraft.network.play.client.C08PacketPlayerBlockPlacement
import net.minecraft.network.play.client.C03PacketPlayer.C04PacketPlayerPosition
import today.sleek.base.value.value.BooleanValue
import today.sleek.client.modules.impl.Module
import today.sleek.client.utils.chat.ChatUtil
import today.sleek.client.utils.network.PacketUtil

@ModuleData(name = "Regen", category = ModuleCategory.EXPLOIT, description = "Automatically regenerates health")
class Regen : Module() {

    private val health = NumberValue("Health", this, 15.0, 1.0, 20.0, 1.0)
    private val packets = NumberValue("Packets", this, 15.0, 1.0, 200.0, 1.0)
    private val modeValue = ModeValue("Mode", this, "Vanilla", "Matrix", "Ghostly" /*/ Credit: Dort / */)

    private val timerBypass = BooleanValue("Timer Bypass", this, true)
    override fun onEnable() {
        if (modeValue.value.equals("matrix", ignoreCase = true)) {
            ChatUtil.log("Credit to Dort")
        }
    }

    @Subscribe
    fun onUpdate(event: UpdateEvent?) {
        if (mc.thePlayer.health >= health.value) return
        if (!mc.thePlayer.onGround) return
        when (modeValue.value) {
            "Vanilla" -> {
                var i = 0
                while (i < packets.value) {
                    mc.thePlayer.sendQueue.addToSendQueue(C03PacketPlayer(true))
                    i++
                }
            }
            "Ghostly" -> {
                if (mc.thePlayer.ticksExisted % 10 == 0) {
                    val d = mc.thePlayer.posX
                    val d2 = mc.thePlayer.posY + 1.0E-9
                    val d3 = mc.thePlayer.posZ
                    var i = 0
                    while (i < packets.value) {
                        mc.thePlayer.sendQueue.addToSendQueue(
                            C06PacketPlayerPosLook(
                                d,
                                d2,
                                d3,
                                mc.thePlayer.rotationYaw,
                                mc.thePlayer.rotationPitch,
                                true
                            )
                        )
                        i++
                    }
                }
            }
            "Matrix" -> {
                var i = 0
                while (i < packets.value.toInt()) {
                    PacketUtil.sendPacketNoEvent(
                        C08PacketPlayerBlockPlacement(
                            mc.thePlayer.position.down(256),
                            256,
                            null,
                            0f,
                            0f,
                            0f
                        )
                    )
                    if (timerBypass.value) PacketUtil.sendPacket(
                        if (timerBypass.value) C04PacketPlayerPosition(
                            mc.thePlayer.posX,
                            mc.thePlayer.posY,
                            mc.thePlayer.posZ,
                            true
                        ) else C03PacketPlayer(true)
                    )
                    i++
                }
            }
        }
    }
}